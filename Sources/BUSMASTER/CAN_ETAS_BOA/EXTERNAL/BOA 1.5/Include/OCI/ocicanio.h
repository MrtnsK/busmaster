#ifndef ETAS_OCI_CAN_IO_H
#define ETAS_OCI_CAN_IO_H

/**
* @file       ocicanio.h
* @brief      CAN specific part of the Open Contoller Interface (OCI) API
*             excluding the stronly typed controller configuration.
* @copyright  Copyright (c) 2007-2008 ETAS GmbH. All rights reserved.
*
* $Revision: 6042 $
*/


#include "ocibase.h"

#ifdef __cplusplus
extern "C" {
#endif

    /**
    * @addtogroup GROUP_OCI_CAN_CONTROLLER OCI CAN
    * @brief      CAN specific part of the Open Controller Interface (OCI).
    * @details    The CAN controller interface instance supports a single
    *             TxQueue and a single RxQueue. All CAN frames will be
    *             queued and transmitted in the same order as they are
    *             delivered via @ref OCI_WriteCANData() to the TxQueue.
    * @{
    */

    /**
    * @addtogroup GROUP_OCI_CAN_INITIALIZATION Initialization
    * @{
    */

    /**
    * Specific structure for CAN controller capabilities.
    *
    * Note that a future version of the OCI_CAN API may define extra fields on the end of this structure. Furthermore,
    * as described in @ref BackwardsCompatibilityPage, such fields should not be accessed unless, at runtime, it can be
    * determined that both client and implementation of OCI_CAN support the required version of the OCI_CAN API. Therefore,
    * when re-compiling code in order to use a new version of this structure, developers should ensure that the code
    * does not unintentionally access such fields, e.g. by using memset() or memcpy().
    */
    typedef struct OCI_CANControllerCapabilities
    {
        /**
        * Specifies the supported samples per bit of this adapter.
        * Valid values are OR-gated into the member.
        * @flags        The following flags are valid:
        * @n            OCI_CAN_ONE_SAMPLE_PER_BIT
        * @n            OCI_CAN_THREE_SAMPLES_PER_BIT
        * @sa           @ref OCI_ANCHOR_CAN_SAMPLES_PER_BIT_VALUES
        *               "OCI CAN samples per bit values"
        */
        uint32 samplesPerBit;

        /**
        * Specifies the supported sync edge mode of this adapter.
        * Valid values are OR-gated into the member.
        * @flags        The following flags are valid:
        * @n            OCI_CAN_SINGLE_SYNC_EDGE
        * @n            OCI_CAN_DUAL_SYNC_EDGE
        * @sa           @ref OCI_ANCHOR_CAN_SYNC_EDGE_VALUES
        *               "OCI CAN sync edge values"
        */
        uint32 syncEdge;

        /**
        * Specifies the supported media types of this adapter.
        * Valid values are OR-gated into the member.
        * @flags        The following flags are valid:
        * @n            OCI_CAN_MEDIA_HIGH_SPEED
        * @n            OCI_CAN_MEDIA_FAULT_TOLERANT
        * @sa           @ref OCI_ANCHOR_CAN_MEDIA_TYPE
        *               "OCI CAN media type"
        */
        uint32 physicalMedia;

        /** Reserved member. Always @c zero */
        uint32 reserved;

        /**
        * Specifies the kind of bus events that can be generated by this
        * adapter. Valid values are OR-gated into the member.
        * @flags        The following flags are valid:

        */
        uint32 busEvents;

        /**
        * Specifies which kind of error frames can be detected and generated
        * by this adapter. Valid values are OR-gated into the member.
        * @flags        The following flags are valid:
        * @n            @ref OCI_CAN_ERR_TYPE_BITSTUFF
        * @n            @ref OCI_CAN_ERR_TYPE_FORMAT
        * @n            @ref OCI_CAN_ERR_TYPE_ACK
        * @n            @ref OCI_CAN_ERR_TYPE_BIT
        * @n            @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
        * @n            @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
        * @n            @ref OCI_CAN_ERR_TYPE_CRC
        * @n            @ref OCI_CAN_ERR_TYPE_OVERLOAD
        * @n            @ref OCI_CAN_ERR_TYPE_OTHER
        * @sa           @ref OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
        *               "CAN error frame types"
        */
        uint32 errorFrames;

        /**
        * Specifies which kind of message flags (message types) are supported by
        * this adapter. Valid values are OR-gated into the member.
        * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
        * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
        * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
        *
        * Note that if the flag @ref OCI_CAN_MSG_FLAG_SELFRECEPTION is set, the OCI_CAN OCD must guarantee that a self-received
        * message is only generated when the original message has actually been transmitted on the CAN bus. In other words, it is
        * @em not permitted to implement self-reception via a OCD-internal loopback.
        *
        * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
        *           "OCI CAN message flags"
        */
        uint32 messageFlags;

    } OCI_CANControllerCapabilities;


    /**
    * Specific structure for the CAN controller status.
    *
    * Note that a future version of the OCI_CAN API may define extra fields on the end of this structure. Furthermore,
    * as described in @ref BackwardsCompatibilityPage, such fields should not be accessed unless, at runtime, it can be
    * determined that both client and implementation of OCI_CAN support the required version of the OCI_CAN API. Therefore,
    * when re-compiling code in order to use a new version of this structure, developers should ensure that the code
    * does not unintentionally access such fields, e.g. by using memset() or memcpy().
    */

    typedef struct OCI_CANControllerStatus
    {
        /* Temporary field */
        uint32 reserved;

    } OCI_CANControllerStatus;


    /**
     Query the capabilities of a specific CAN controller instance.

     The capabilities are static information, which will never change for a specific instance.

     @controllerState CREATED, SUSPENDED, RUNNING.

     @param[in]  controller   Handle of the CAN controller interface instance for which the status is requested.
     @param[out] capabilities Pointer to a buffer receiving the requested capability information of the CAN
                              controller.

     @return
       <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. The @capabilities are filled with valid information. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a controller handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a capabilities paramter is NULL or references an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_TIMEOUT </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 The state of the session is undefined. All subsequent calls will return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyFlexRayController() for this handle called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more. The state of the session is undefined. All subsequent calls to the same
                 controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyFlexRayController() for this handle is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>
    */
#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_GetCANControllerCapabilities(
        OCI_ControllerHandle controller,
        OCI_CANControllerCapabilities* capabilities);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_GetCANControllerCapabilities)(
        OCI_ControllerHandle controller,
        OCI_CANControllerCapabilities* capabilities);

    /**
     Query the status of a specific CAN controller instance.

     The status information of a CAN controller may change by some events on the CAN bus.

     @controllerState CREATED, SUSPENDED, RUNNING.

     @param[in]  controller  handle of the CAN controller interface instance for which the status is requested.
     @param[out] status      Pointer to a buffer receiving the requested status information of the CAN controller.

     @return
       <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. The @a status information is filled with valid information </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a controller handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a status paramter is NULL or references an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>

    */
#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_GetCANControllerStatus(
        OCI_ControllerHandle controller,
        OCI_CANControllerStatus* status);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_GetCANControllerStatus)(
        OCI_ControllerHandle controller,
        OCI_CANControllerStatus* status);

    /**
    * @}
    * @addtogroup GROUP_OCI_CAN_QUEUES Queues
    * @{
    */

    struct OCI_CANMessage;

    /**
     Signature of a callback function for CAN event and message handling. A callback function matching this signature is
     able to receive only one CAN event or message in a single invocation. The alternative, @ref OCI_CANRxCallbackFunction,
     is able to receive multiple CAN events and/or messages per invocation.

     @param[in] userData When the callback is executed, this argument will contain the value of the field @ref OCI_CANRxCallbackSingleMsg::userData
                         which was supplied to @ref OCI_CreateCANRxQueue() when the RX queue was created. This value is
                         opaque to the BOA framework. It is only meaningful to the BOA client.
     @param[in] msg      The received message or event. The object is owned by the caller of the API. The reference must
                         not used after completion of the callback. When the user requires access to the data after
                         completion of the callback the callback must create a copy of the data.
    */
    typedef void (OCI_CALLBACK* OCI_CANRxCallbackFunctionSingleMsg)( void* userData, struct OCI_CANMessage* msg );


    /**
        \brief Callback for CAN event and message handling

        The callback consists of a callback function and context information (user data),
        e.g. a queue handle or a pointer to some related data structure controlled by
        the program that uses OCI.

        The OCI user sets a callback when creating an RX queue.
    */
    typedef struct OCI_CANRxCallbackSingleMsg
    {
        /** Callback function pointer */
        OCI_CANRxCallbackFunctionSingleMsg function;

        /**
         * Opaque context information that will be passed to the callback
         * @a function. The pointer is supplied by the caller and not
         * interpreted or modified by the OCD implementation.
         * May be @c NULL.
         */
        void* userData;

    } OCI_CANRxCallbackSingleMsg;


    /**
     * Specific structure for the CAN RX queue configuration.
     *
     * Note that a future version of the OCI_CAN API may define extra fields on the end of this structure. Furthermore,
     * as described in @ref BackwardsCompatibilityPage, such fields should not be accessed unless, at runtime, it can be
     * determined that both client and implementation of OCI_CAN support the required version of the OCI_CAN API. Therefore,
     * when re-compiling code in order to use a new version of this structure, developers should ensure that the code
     * does not unintentionally access such fields, e.g. by using memset() or memcpy().
     */

    typedef struct OCI_CANRxQueueConfiguration
    {
        /**
        * Callback function for the reception of a CAN single frame.
        *
        * When a frame arrives which matches one of the frame filters defined for the queue instance,
        * there are two possibilities:
        *   - If @ref onFrame is not @c NULL, the frame is passed to @ref onFrame.
        *   - If @ref onFrame is @c NULL, the frame is added to the RX queue.
        *
        * Note that if @ref OCI_DestroyCANRxQueue() or @ref OCI_DestroyCANController() is called while reception
        * is in progress, it is possible for a final call to @ref onFrame to be made a short time @em after
        * @ref OCI_DestroyCANRxQueue() or @ref OCI_DestroyCANController() has returned successfully.
        *
        * @sa @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
        */
#ifndef MIDL_RUNNING
        OCI_CANRxCallbackSingleMsg onFrame;
#endif

        /**
        * Callback function for the reception of a single event.
        *
        * When an event is fired which matches one of the event filters defined for the queue instance,
        * there are several possibilities:
        *   - If @ref onEvent is not @c NULL, and if the @c destination member of the matched filter specifies
        *     @ref OCI_EVENT_DESTINATION_CALLBACK, then the event is passed to @ref onEvent.
        *   - If the @c destination member of the matched filter specifies @ref OCI_EVENT_DESTINATION_INBAND,
        *     then the event is delivered to the application in the same way as a data frame.
        *   - If @ref onEvent is @c NULL, then the event is always delivered to the application in the
        *     same way as a data frame.
        *
        * Note:
        *   - The @c destination member of a filter can specify both @ref OCI_EVENT_DESTINATION_CALLBACK and
        *     @ref OCI_EVENT_DESTINATION_INBAND. In other words, the first two possibilities above are not mutually
        *     exclusive.
        *   - See @ref onFrame for a description of how received data frames are delivered to the application.
        *   - If @ref OCI_DestroyCANRxQueue() or @ref OCI_DestroyCANController() is called while reception
        *     is in progress, it is possible for a final call to @ref onEvent to be made a short time @em after
        *     @ref OCI_DestroyCANRxQueue() or @ref OCI_DestroyCANController() has returned successfully.
        *   - Setting only @ref onEvent but not @ref onFrame allows a lazy reaction on frame reception and a
        *     quick reaction on every enabled event.
        *
        * @sa   @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
        * @sa   OCI_QueueEventFilter
        */
#ifndef MIDL_RUNNING
        OCI_CANRxCallbackSingleMsg onEvent;
#endif

        /**
        * Specify whether self-recepted frames shall be forwarded to this queue.
        * @note        This flag will be AND-gated with the respective
        *              @ref OCI_CANConfiguration setting.
        * @values      The following values are valid:
        * @n           OCI_SELF_RECEPTION_OFF
        * @n           OCI_SELF_RECEPTION_ON
        * @sa          @ref OCI_SelfReceptionMode
        *              "OCI Self Reception Mode"
        */
        OCI_SelfReceptionMode selfReceptionMode;
    } OCI_CANRxQueueConfiguration;


    /**
     * Specific structure for the CAN TX queue configuration.
     * This structure is currently reserved and has no members.
     *
     * Note that a future version of the OCI_CAN API may define extra fields on the end of this structure. Furthermore,
     * as described in @ref BackwardsCompatibilityPage, such fields should not be accessed unless, at runtime, it can be
     * determined that both client and implementation of OCI_CAN support the required version of the OCI_CAN API. Therefore,
     * when re-compiling code in order to use a new version of this structure, developers should ensure that the code
     * does not unintentionally access such fields, e.g. by using memset() or memcpy().
     */

    typedef struct OCI_CANTxQueueConfiguration
    {
        /** Reserved for future use. Set to @c zero.*/
        uint32 reserved;

    } OCI_CANTxQueueConfiguration;


    /**
      Create a a receive queue or register callback functions for frame reception for a specific CAN controller.

      CAN controller allow a single receive queue per controller. The configuration parameter allows the
      registration of a callback function for frames and a callback function for events. When these callbacks are
      set to NULL the data will be queued and must be read by OCI_ReadCANData(). When the callbacks are set
      the data will not be stored in the queue, but a reference is passed to the callback function whenever a frame
      is received.

      All Frames and Events must pass a white filter to be stored in the queue. The filter conditions must be set
      by OCI_AddCANFrameFilter(), OCI_AddCANErrorFrameFilter() and OCI_AddCANBusEventFilter(). After creation of a
      receive queue the queue will not receive any data, because no white filter is active and all data is blocked.

      @controllerState SUSPENDED, RUNNING.

      @param[in]  controller     Handle of the controller instance.
      @param[in]  configuration  Pointer to the buffer that contains the configuration structure.
      @param[out] queue          Handle of the newly created receive queue.

      @return
       <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful.
                 The @a queue handle is vaild and must be used in any subsequent call accessing the queue. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a controller handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a configuration paramter or queue parameter is NULL or references to an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_STATE </td>
            <td> The @a controller was not opened. The controller is not in the @a RUNNING or @a SUSPENDED state. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_NO_RESOURCES </td>
            <td> The @a controller already has a receive queue, it is not possible to create a second queue.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_WARN_INCONSISTENT_SELF_RECEPTION </td>
            <td> @p configuration specifies that self-reception should be enabled for the queue, whereas the associated
                 controller is not configured for self-reception; or vice versa. This may be intentional, or may indicate
                 a mistake in the configuration of the controller and queue. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> An unexpected implementation error occured. </td>
       </tr>
      </TABLE>
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_CreateCANRxQueue(
        OCI_ControllerHandle controller,
        OCI_CANRxQueueConfiguration* configuration,
        OCI_QueueHandle* queue);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_CreateCANRxQueue)(
        OCI_ControllerHandle controller,
        OCI_CANRxQueueConfiguration* configuration,
        OCI_QueueHandle* queue);


    /**
      Destroy a receive queue and unregister callback routines for data and event reception for a specific CAN controller.

      Any data in the queue, that is not read by OCI_ReadCANData() will be discarded. The registered callback routines
      for data reception and event reception (see @ref OCI_CANRxQueueConfiguration) will not be called after completion of
      this routine. All white filter added to this queue will be discarded.

      The handle for the queue must not used any longer.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE. \n
                       When the controller is in the DISCONNECTED state the function may be called to do local clean
                       up.

      @param[in]  queue  Handle of the queue.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. The queue is destroyed and the handle must not be used any longer. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>

       </TABLE>
     */
#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_DestroyCANRxQueue(
        OCI_QueueHandle queue);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_DestroyCANRxQueue)(
        OCI_QueueHandle queue);


    /**
      Create a CAN transmit queue.

      A transmit queue is necessary to transmit frames for a specific CAN controller instance. CAN controller
      support only a single transmit queue. All frames written to the transmit queue by OCI_WriteCANData() will
      be sent in the same order on the CAN-Bus.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.

      @param[in]  controller     The handle of the controller instance.
      @param[in]  configuration  The configuration of the transmit queue.
      @param[out] queue          Receives the handle of the newly created transmit queue.

     @return
       <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful.
                 The @a queue handle is valid and can be used for any subsequent access to the queue. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a controller handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a configuration parameter or @a queue parameter is NULL or references an invalid object.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_NO_RESOURCES </td>
            <td> The @a controller already has a transmit queue, it is not possible to create a second queue.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> An unexpected implementation error occured. </td>
       </tr>
      </TABLE>
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_CreateCANTxQueue(
        OCI_ControllerHandle controller,
        OCI_CANTxQueueConfiguration* configuration,
        OCI_QueueHandle* queue);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_CreateCANTxQueue)(
        OCI_ControllerHandle controller,
        OCI_CANTxQueueConfiguration* configuration,
        OCI_QueueHandle* queue);


    /**
     Destroy a CAN transmit queue.

     The transmission Queue of a CAN controller is destroyed and all resources used by the queue are released. If the
     queue is not empty and some frames are waiting for transmission the frames are silently discarded. If the
     application wants to be sure, that all frames are send before the queue is destroyed it can use the
     OCI_GetQueueStatus() command to wait for an empty queue before calling this command.

     The handle is invalid after this call and must not be used any longer.

     @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.
                       When the controller is in the DISCONNECTED state the function may be called to do local clean
                       up.

     @note Frames already stored in the send register of a CAN controller, but stalled by higher prior messages on the
           Bus may be sent, when the controller wins arbitration, even when this call already returned and the send
           queue is invalid.

     @param[in] queue The handle of the queue to destroy.

     @return
       <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful.
                 The @a queue is destroyed and the handle must not be used any longer.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> An unexpected implementation error occured. </td>
       </tr>
      </TABLE> */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_DestroyCANTxQueue(
        OCI_QueueHandle queue);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_DestroyCANTxQueue)(
        OCI_QueueHandle queue);


    /**
    * @}
    * @addtogroup GROUP_OCI_CAN_FILTERING Filter
    * @{ */


    /**
    * Structure that defines a single CAN (read) frame filter. For a given
    * logical link, there may be a number of frame filters. A frame will
    * pass them and be added to the receive queue, if it matches the condition
    * of at least one of them.
    *
    * A frame filter describes a mask conditions:
    *
    * pass =    ((frame.ID & @a frameIDMask) == @a frameIDValue)
    */

    typedef struct OCI_CANRxFilter
    {
        /**
        * Value that the frame id must match after AND-gating it with
        * @a frameIDMask.
        */

        uint32 frameIDValue;

        /**
        * Bit mask to be applied to the frame id. If the frame id is shorter
        * than 32 bits, the "missing" high bits are padded with 0.
        */

        uint32 frameIDMask;

        /**
        * Application defined filter tag. All received frames which match
        * this filter are tagged with this value.
        */
        uint32 tag;

    } OCI_CANRxFilter;


    /**
    * @anchor  OCI_ANCHOR_CAN_BUS_EVENTS
    * @name    OCI CAN configuration values for the media type.
    * @brief   Constant values to specify the kind of a CAN bus event.
    *          These are possible values of @ref OCI_CANEventFilter.event.
    *
    * @{ */

    /** The CAN controller has switched into the active state. */
#define OCI_CAN_BUS_EVENT_STATE_ACTIVE              (0x00000001u)

    /** The CAN controller has switched into the passive state. */
#define OCI_CAN_BUS_EVENT_STATE_PASSIVE             (0x00000002u)

    /** The warning limit of the error counter has exceeded. */
#define OCI_CAN_BUS_EVENT_STATE_ERRLIMIT            (0x00000004u)

    /** The controller has switched into the bus off state. */
#define OCI_CAN_BUS_EVENT_STATE_BUSOFF              (0x00000008u)

    /**
     * The controller has switched to single wire mode.
     * (fault tolerant physical medium only)
     */
#define OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE (0x00000010u)

    /** @} */

    /**
    * Specific structure to define a filter for a CAN bus event.
    */

    typedef struct OCI_CANEventFilter
    {
        /**
        * Specifies which kind of CAN bus event this filter matches
        * Valid values may be OR-gated as flags into the member to
        * specify that this filter matches multiple events.
        * The value of @a event is internally AND-gated with
        * @ref OCI_CANControllerCapabilities.busEvents.
        * @flags       The following flags are valid:
        * @n           @ref OCI_CAN_BUS_EVENT_STATE_ACTIVE
        * @n           @ref OCI_CAN_BUS_EVENT_STATE_PASSIVE
        * @n           @ref OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
        * @n           @ref OCI_CAN_BUS_EVENT_STATE_BUSOFF
        * @n           @ref OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
        * @sa          OCI_ANCHOR_CAN_BUS_EVENTS
        *              "OCI CAN bus events"
        */
        uint32 eventCode;

        /**
        * Application defined filter tag. All received events which match
        * this filter are tagged with this value.
        */
        uint32 tag;

        /**
        * Destination of the event. When @ref OCI_EVENT_DESTINATION_INBAND
        * is set, the event will be delivered inband to the application.
        * When the @ref OCI_EVENT_DESTINATION_CALLBACK is set the event
        * will trigger the event handler of the receive queue for that
        * event. When both flags are combined the event is duplicated and
        * the callback is triggered and the event is stored inband in the
        * queue.
        */
        uint32 destination;

    } OCI_CANEventFilter;


    /**
    * Specific structure to define a CAN error frame filter.
    */

    typedef struct OCI_CANErrorFrameFilter
    {
        /**
        * Specifies which kind of CAN error frames this filter matches.
        * Valid values may be OR-gated as flags into the member to
        * specify that this filter matches different kinds of error frames.
        * The value of @a errorFrame is internally AND-gated with
        * @ref OCI_CANControllerCapabilities.errorFrames.
        * @flags        The following flags are valid:
        * @n            @ref OCI_CAN_ERR_TYPE_BITSTUFF
        * @n            @ref OCI_CAN_ERR_TYPE_FORMAT
        * @n            @ref OCI_CAN_ERR_TYPE_ACK
        * @n            @ref OCI_CAN_ERR_TYPE_BIT
        * @n            @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
        * @n            @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
        * @n            @ref OCI_CAN_ERR_TYPE_CRC
        * @n            @ref OCI_CAN_ERR_TYPE_OVERLOAD
        * @n            @ref OCI_CAN_ERR_TYPE_OTHER
        * @sa           OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
        *               "CAN error frame types"
        */
        uint32 errorFrame;

        /**
        * Application defined filter tag. All received events which match
        * this filter are tagged with this value.
        */
        uint32 tag;

        /**
        * Destination of the event. When @ref OCI_EVENT_DESTINATION_INBAND
        * is set, the event will be delivered inband to the application.
        * When the @ref OCI_EVENT_DESTINATION_CALLBACK is set the event
        * will trigger the event handler of the receive queue for that
        * event. When both flags are combined the event is duplicated and
        * the callback is triggered and the event is stored inband in the
        * queue.
        */
        uint32 destination;

    } OCI_CANErrorFrameFilter;


    /**
      Add white filter condition(s) to enable the reception of CAN frames for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows the reception of specific CAN frames identified by a masked CAN-ID on the CAN bus.
      The frames may be queued and read by OCI_ReadCANData() or a callback is triggered whenever a frame passes
      the filter. The signalization path to the application is defined by the creation of the receive queue.
      (See OCI_CreateCANRxQueue()).

      Filter conditions allow an effective reduction of the payload, that must be handled by the driver and
      application. The sequence of processing the filter array is undefined. When a frame matches to more than
      one filter the frame will be passed to the application, but the used filter tag (identifying the matching
      filter) is implementation specific and may change in different versions and on different hardware.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.

      @param[in]  queue    Handle of the CAN receive queue that will receive the messages.
      @param[in]  filter   A pointer to an array of @a count entries of type @ref OCI_CANRxFilter.
      @param[in]  count    Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are added.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter parameter is NULL, references an invalid address or the filter already exists.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_NO_RESOURCES </td>
            <td> The limit of the filters that can be handled by the driver is exceeded. It is not possible to add
                 any more filters. A hardware implementation may limit the number of supported filters to avoid an
                 overload of the hardware. Some implementations may share the filter resources between all logical
                 controller instances of a hardware controller or even all logical controllers of a hardware system.
                 Terminate other application that access the same system to release resources required by them.
                 </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> An unexpected implementation error in the driver occured. Please contact the vendor of the driver. </td>
       </tr>

      </TABLE>

      @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES.
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_AddCANFrameFilter(
        OCI_QueueHandle queue,
        OCI_CANRxFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_AddCANFrameFilter)(
        OCI_QueueHandle queue,
        OCI_CANRxFilter filter[],
        uint32 count);

    /**
      Remove white filter condition(s) to disable the reception of CAN frames for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows to withdraw one or more white filter conditions set by OCI_AddCANFrameFilter(). Each
      @ref OCI_CANRxFilter of the @a filter array must exact match to a previously added filter. It is
      not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
      one.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE. \n
                       When the controller is in the DISCONNECTED state the function may be called to do local clean
                       up. Only a limitied plausibility check may be done in this case.

      @param[in]  queue    Handle of the CAN receive queue from which are filter withdrawn.
      @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANRxFilter.
      @param[in]  count    Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are withdrawn. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter paramter is NULL or references an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_FILTER_UNKNOWN </td>
            <td> One or more @a filter objects are not set and can not be removed.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more @a filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>

      @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES.
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_RemoveCANFrameFilter(
        OCI_QueueHandle queue,
        OCI_CANRxFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_RemoveCANFrameFilter)(
        OCI_QueueHandle queue,
        OCI_CANRxFilter filter[],
        uint32 count);


    /**
      Add white filter condition(s) to enable the reception of CAN bus events for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows the reception of specific events on the CAN bus. The events may be delivered in-order
      in the normal data stream or generate a callback. The signalization path to the application is defined by
      the creation of the receive queue and by the definition of the filter condition in this call.
      For any filter in the array it is possible to set OCI_CANEventFilter::destination to a combination of
      @li  @ref OCI_EVENT_DESTINATION_CALLBACK
           The event will generate the OCI_CANRxQueueConfiguration::onEvent callback.
      @li  @ref OCI_EVENT_DESTINATION_INBAND
           The event will use the same path as any received frame. Dependent on the configuration of the Queue the
           event will generate the OCI_CANRxQueueConfiguration::onFrame callback or will be queued. Queued events
           and frames can be read by OCI_ReadCANData().

      When both Flags are set the event will be duplicated and use both signalization paths.
      When no Flag is set @ref OCI_ERR_INVALID_FILTER is returned.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.

      @param[in]  queue    Handle of the CAN receive queue that will receive the event(s).
      @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANEventFilter.
      @param[in]  count    Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are added. The events will be received. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter parameter is NULL, references an invalid address or the filter already exists.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>

      @sa GROUP_OCI_EVENT_HANDLING, @ref PAGE_OCI_RECEIVE_MESSAGES "Receive Messages"
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_AddCANBusEventFilter(
        OCI_QueueHandle queue,
        OCI_CANEventFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_AddCANBusEventFilter)(
        OCI_QueueHandle queue,
        OCI_CANEventFilter filter[],
        uint32 count);


    /**
      Remove white filter condition(s) to disable the reception of CAN-Bus events for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows to withdraw one or more white filter conditions set by OCI_AddCANBusEventFilter(). Each
      @ref OCI_CANEventFilter of the @a filter array must exact match to a previously added filter. It is
      not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
      one.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE. \n
                       When the controller is in the DISCONNECTED state the function may be called to do local clean
                       up. Only a limitied plausibility check may be done in this case.

      @param[in]  queue   Handle of the CAN receive queue to modify.
      @param[in]  filter  Pointer to an array of @a count entries of type @ref OCI_CANEventFilter.
      @param[in]  count   Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are withdrawn. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter paramter is NULL or references an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_FILTER_UNKNOWN </td>
            <td> One or more @a filter objects are not set and can not be removed.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more @a filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_RemoveCANBusEventFilter(
        OCI_QueueHandle queue,
        OCI_CANEventFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_RemoveCANBusEventFilter)(
        OCI_QueueHandle queue,
        OCI_CANEventFilter filter[],
        uint32 count);


    /**
      Add white filter condition(s) to enable the reception of CAN error frames for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows the reception of CAN Error frames. The error frames may be delivered in-order
      in the normal data stream or generate a callback.  The signalization path to the application is defined by
      the creation of the receive queue and by the definition of the filter condition in this call.
      @li  When the OCI_CANErrorFrameFilter::destination is @ref OCI_EVENT_DESTINATION_CALLBACK the error frames
           will generate the OCI_CANRxQueueConfiguration::onEvent callback.
      @li  When the OCI_CANErrorFrameFilter::destination is @ref OCI_EVENT_DESTINATION_INBAND the error frames
           will use the same path as any received frame. Dependent on the configuration of the Queue the error frames
           will generate the OCI_CANRxQueueConfiguration::onFrame callback or will be queued. Queued error frames
           (and CAN frames) can be read by OCI_ReadCANData().

      When both Flags are set the event will be duplicated and use both signalization paths.
      When no Flag is set @ref OCI_ERR_INVALID_FILTER is returned.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.

      @param[in]  queue    Handle of the CAN receive queue that will receive the event(s).
      @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANErrorFrameFilter.
      @param[in]  count    Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are added. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter parameter is NULL, references an invalid address or the filter already exists.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> An unexpected implementation error in the driver occured. Please contact the vendor of the driver. </td>
       </tr>
      </TABLE>
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_AddCANErrorFrameFilter(
        OCI_QueueHandle queue,
        OCI_CANErrorFrameFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_AddCANErrorFrameFilter)(
        OCI_QueueHandle queue,
        OCI_CANErrorFrameFilter filter[],
        uint32 count);


    /**
      Remove white filter condition(s) to disable the reception of CAN-Error Frames for a specific CAN receive queue.

      In the default configuration of a receive queue no data will be received because any data is blocked by
      some filter condition. The application must enable the reception of the data by setting white filter
      (defining pass conditions).

      This function allows to withdraw one or more white filter conditions set by OCI_AddCANErrorFrameFilter(). Each
      @ref OCI_CANErrorFrameFilter of the @a filter array must exact match to a previously added filter. It is
      not possible to restrict an existing white filter, without redrawing it and adding a new more restrictive
      one.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE. \n
                       When the controller is in the DISCONNECTED state the function may be called to do local clean
                       up. Only a limitied plausibility check may be done in this case.

      @param[in]  queue    Handle of the CAN receive queue to modify.
      @param[in]  filter   Pointer to an array of @a count entries of type @ref OCI_CANErrorFrameFilter.
      @param[in]  count    Number of entries in the @a filter array.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a filter are withdrawn. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a filter paramter is NULL or points to an invalid object.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_FILTER_UNKNOWN </td>
            <td> One or more @a filter objects are not set and can not be removed.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> One or more @a filter objects are invalid or the same filter is defined more than once in the filter set.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
      </TABLE>
    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_RemoveCANErrorFrameFilter(
        OCI_QueueHandle queue,
        OCI_CANErrorFrameFilter filter[],
        uint32 count);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_RemoveCANErrorFrameFilter)(
        OCI_QueueHandle queue,
        OCI_CANErrorFrameFilter filter[],
        uint32 count);


    /**
    * @}
    * @addtogroup GROUP_OCI_CAN_MESSAGES Messages
    * @{
    */

    /**
    * @anchor ANCHOR_OCI_MESSAGE_TYPES
    * @name   OCI Message Types.
    * @brief  Possible values of @ref OCI_CANMessage.type.
    *         The values are used to select a specific part of a discriminated
    *         union.
    * @{
    */

    typedef enum OCI_CANMessageDataType
    {
        /** Message type is @ref OCI_CANRxMessage */
        OCI_CAN_RX_MESSAGE                          = 1,

        /** Message type is @ref OCI_CANTxMessage */
        OCI_CAN_TX_MESSAGE                          = 2,

        /** Message type is @ref OCI_CANErrorFrameMessage */
        OCI_CAN_ERROR_FRAME                         = 3,

        /** Message type is @ref OCI_CANEventMessage */
        OCI_CAN_BUS_EVENT                           = 4,

        /** Message type is @ref OCI_InternalErrorEvent*/
        OCI_CAN_INTERNAL_ERROR_EVENT                = 5,

        /** Message type is @ref OCI_QueueEvent */
        OCI_CAN_QUEUE_EVENT                         = 6,

        /** Message type is @ref OCI_TimerEvent */
        OCI_CAN_TIMER_EVENT                         = 7

    } OCI_CANMessageDataType;

    /** @} */


    /**
    * @anchor  ANCHOR_OCI_CAN_MESSAGE_FLAGS
    * @name    OCI CAN Message Flags.
    * @brief   Flags to specify additional information of a CAN message.
    *          These are possible values of @ref OCI_CANRxMessage.flags.
    */

    /** @{ */
    /**
    * Message with extended 29-bit ID. If this flag is not set, the associated message has a standard 11-bit ID and bits 12-29
    * of the message ID will be ignored.
    */
#define OCI_CAN_MSG_FLAG_EXTENDED               (0x1u)

    /**
    * The message is a remote frame.
    */
#define OCI_CAN_MSG_FLAG_REMOTE_FRAME           (0x2u)

    /**
    * The message is a self reception frame.
    *
    * Note that if this flag is set on a received CAN message, the OCI_CAN OCD must guarantee that the originally-transmitted
    * message (to which the self-received message corresponds) has actually been transmitted on the CAN bus. In other words, it is
    * @em not permitted to implement self-reception via an OCD-internal loopback.
    */
#define OCI_CAN_MSG_FLAG_SELFRECEPTION          (0x4u)

    /** @} */


    /**
    * Specific structure for CAN bus data messages.
    */

    typedef struct OCI_CANTxMessage
    {
        /** CAN frame ID. */
        uint32 frameID;

        /**
        * Additional information and settings of the CAN data message. Note that if @ref OCI_CAN_MSG_FLAG_EXTENDED is not set,
        * @ref frameID will be considered to represent a standard ID, so bits 12-29 of @ref frameID will be ignored.
        * @flags    The following flags are valid:
        * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
        * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
        * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
        * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
        *           "OCI CAN Message Flags"
        */
        uint16 flags;

        /** Reserved data field. */
        uint8 res;

        /**
         * The data length code (DLC) of the CAN frame to be transmitted. Usually, the DLC indicates the number of data bytes in
         * the frame, (i.e. the number of valid bytes in @ref data) and is therefore <= 8. However, the CAN specification implicitly
         * permits DLC values which are > 8 and <= 15, though in such a case the frame will still contain only 8 data bytes.
         * Consequently, some CAN controllers are able to transmit a frame with DLC > 8, though such a frame still only contains 8
         * data bytes. The OCI_CAN API allows a caller to request the transmission of such a frame, though the underlying OCD may
         * refuse to transmit the frame and return an error.
         */
        uint8 dlc;

        /** Payload. If @ref dlc is <= 8, only the first @ref dlc bytes are valid. If @ref dlc is > 8, all 8 bytes are valid. */
        uint8 data[8];

    } OCI_CANTxMessage;

    /** Specific structure for CAN bus data frames. */
    typedef struct OCI_CANRxMessage
    {
        /**
        * Global receive time stamp. Depending on the implementation, this may be
        * based on a hardware-internal timer with no global synchronization.
        * In particular, the epoch (i.e.\ value 0) may be the point in time the
        * hardware was switched on.
        */
        OCI_Time timeStamp;

        /** Filter tag ID. This ID is set by the definition of the RxFilter. */
        uint32 tag;

        /** CAN frame ID. */
        uint32 frameID;

        /**
        * Additional information and settings of the CAN data message.
        * @flags    The following flags are valid:
        * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
        * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
        * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
        *
        * Note that if the flag @ref OCI_CAN_MSG_FLAG_SELFRECEPTION is set on a received CAN message, the OCI_CAN OCD must guarantee
        * that the originally-transmitted message (to which the self-received message corresponds) has actually been transmitted on
        * the CAN bus. In other words, it is @em not permitted to implement self-reception via an OCD-internal loopback.
        *
        * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
        *           "OCI CAN Message Flags"
        */
        uint16 flags;

        /** Reserved data field. */
        uint8 res;

        /**
         * The data length code (DLC) of the received CAN frame. Usually, the DLC indicates the number of data bytes in the frame,
         * (i.e. the number of valid bytes in @ref data) and is therefore <= 8. However, the CAN specification implicitly permits
         * DLC values which are > 8 and <= 15, though in such a case the frame will still contain only 8 data bytes. Consequently,
         * some CAN controllers are able to receive a frame with DLC > 8 (though such a frame still only contains 8 data bytes),
         * and the OCI_CAN API will process such a frame as usual, except that @ref dlc will be > 8 and @ref data will contain 8 bytes.
         */
        uint8 dlc;

        /** keep 64 Bit alignment for first data byte */
        uint8 res1[4];

        /** Payload. If @ref dlc is <= 8, only the first @ref dlc bytes are valid. If @ref dlc is > 8, all 8 bytes are valid. */
        uint8 data[8];

    } OCI_CANRxMessage;


    /**
    * @anchor  OCI_ANCHOR_CAN_ERROR_FRAME_TYPES
    * @name    OCI CAN Error Frame Types.
    * @brief   Constants to specify the content of a error frame.
    *          These constants are valid for @ref OCI_CANErrorFrameMessage.type.
    */

    /** @{ */
    /** Bit stuff error */
#define OCI_CAN_ERR_TYPE_BITSTUFF               (0x00000001u)

    /** Format error */
#define OCI_CAN_ERR_TYPE_FORMAT                 (0x00000002u)

    /** Acknowledge error */
#define OCI_CAN_ERR_TYPE_ACK                    (0x00000004u)

    /** Bit error */
#define OCI_CAN_ERR_TYPE_BIT                    (0x00000008u)

    /** CRC error */
#define OCI_CAN_ERR_TYPE_CRC                    (0x00000010u)

    /**
      * Bit error desired recessive but monitored dominant
      * Could happen if e.g. another node or the physical
      * layer driver is defect and produces a permenant dominant
      * level.
      */
#define OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT (0x00000020u)


    /**
      * Bit error desired dominant but monitored recessive
      * Could happen if e.g. the bus topilogy wasn't correctly
      * designed
      */

#define OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV (0x00000040u)

    /** Overload error */
#define OCI_CAN_ERR_TYPE_OVERLOAD               (0x00000080u)

    /** Other unspecified error */
#define OCI_CAN_ERR_TYPE_OTHER                  (0x80000000u)

    /** Unknown error
    */
#define OCI_CAN_ERR_TYPE_UNKNOWN                (0x80000000u)
    /** @} */


    /**
    * Specific structure for CAN bus data messages.
    */

    typedef struct OCI_CANErrorFrameMessage
    {
        /**
        * Global receive time stamp. Depending on the implementation,
        * this may be based on a hardware-internal timer with no global
        * synchronization. In particular, the epoch (i.e.\ value 0) may
        * be the point in time the hardware was switched on.
        */
        OCI_Time timeStamp;

        /**
        * CAN filter tag ID. This ID matches the @ref OCI_CANErrorFrameFilter.tag
        * of the first defined frame filter which caused this frame to be
        * received.
        */
        uint32 tag;

        /** CAN frame ID. May be @c 0xffffffff if unknown*/
        uint32 frameID;

        /**
         * Additional information and settings of the CAN data message.
         * @flags    The following flags are valid:
         * @n        @ref OCI_CAN_MSG_FLAG_EXTENDED
         * @n        @ref OCI_CAN_MSG_FLAG_REMOTE_FRAME
         * @n        @ref OCI_CAN_MSG_FLAG_SELFRECEPTION
         * @sa       @ref ANCHOR_OCI_CAN_MESSAGE_FLAGS
         *           "OCI CAN Message Flags"
         */
        uint16 flags;

        /** Reserved data field. */
        uint8 res;

        /**
        * Number of (valid) data bytes.
        * CAN allows for frames to be shorter than 8 bytes.
        * May be @c 0xff if unknown
        */
        uint8 dlc;

        /**
        * Type of the error frame. If this feature is not supported,
        * the value is always @ref OCI_CAN_ERR_TYPE_UNKNOWN.
        * @values   The following values are valid:
        * @n        @ref OCI_CAN_ERR_TYPE_BITSTUFF
        * @n        @ref OCI_CAN_ERR_TYPE_FORMAT
        * @n        @ref OCI_CAN_ERR_TYPE_ACK
        * @n        @ref OCI_CAN_ERR_TYPE_BIT
        * @n        @ref OCI_CAN_ERR_TYPE_BIT_RECSV_BUT_DOMINANT
        * @n        @ref OCI_CAN_ERR_TYPE_BIT_DOMINANT_BUT_RECSV
        * @n        @ref OCI_CAN_ERR_TYPE_CRC
        * @n        @ref OCI_CAN_ERR_TYPE_OVERLOAD
        * @n        @ref OCI_CAN_ERR_TYPE_OTHER
        * @n        @ref OCI_CAN_ERR_TYPE_UNKNOWN
        * @sa       @ref ANCHOR_OCI_CAN_ERROR_FRAME_TYPES
        *           "OCI CAN Error Frame Types"
        */
        uint32 type;

        /**
        * Destination of the event. The event message will use the combination
        * of @ref OCI_EVENT_DESTINATION_INBAND and
        * @ref OCI_EVENT_DESTINATION_CALLBACK that was
        * registered for this event by calling OCI_AddCANBusEventFilter().
        */
        uint32 destination;
    } OCI_CANErrorFrameMessage;


    /**
    * Specific structure for CAN bus events.
    */

    typedef struct OCI_CANEventMessage
    {
        /**
         * Global receive time stamp. Depending on the implementation,
         * this may be based on a hardware-internal timer with no global
         * synchronization. In particular, the epoch (i.e.\ value 0) may
         * be the point in time the hardware was switched on.
         */
        OCI_Time timeStamp;

        /**
        * Filter tag specified in @ref OCI_CANEventFilter.
        */
        uint32 tag;

        /**
         * Specifies the of CAN bus events.
         * Valid values may be OR-gated as flags into the member to
         * specify that this filter matches multiple events.
         * The value of @a event is internally AND-gated with
         * @ref OCI_CANControllerCapabilities.busEvents.
         * @flags       The following flags are valid:
         * @n           @ref OCI_CAN_BUS_EVENT_STATE_ACTIVE
         * @n           @ref OCI_CAN_BUS_EVENT_STATE_PASSIVE
         * @n           @ref OCI_CAN_BUS_EVENT_STATE_ERRLIMIT
         * @n           @ref OCI_CAN_BUS_EVENT_STATE_BUSOFF
         * @n           @ref OCI_CAN_BUS_EVENT_FAULT_TOLERANT_SINGLE_WIRE
         * @sa          OCI_ANCHOR_CAN_BUS_EVENTS
         *              "OCI CAN bus events"
         */
        uint32 eventCode;

        /**
        * Destination of the event. The event message will use the combination
        * of @ref OCI_EVENT_DESTINATION_INBAND and
        * @ref OCI_EVENT_DESTINATION_CALLBACK that was
        * registered for this event by calling OCI_AddCANBusEventFilter().
        */
        uint32 destination;

    } OCI_CANEventMessage;
    /**
    * Shared structure of CAN bus relevant data.
    */

    typedef
#ifdef MIDL_RUNNING
    [switch_type(OCI_CANMessageDataType)]
#endif
    union OCI_CANMessageData
    {
        /**
        * Read Data of a CAN message.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_RX_MESSAGE.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_RX_MESSAGE)]
#endif
            OCI_CANRxMessage rxMessage;

        /**
        * Write data of a CAN message.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_TX_MESSAGE.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_TX_MESSAGE)]
#endif
            OCI_CANTxMessage txMessage;

        /**
        * Information about a bus error.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_ERROR_FRAME.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_ERROR_FRAME)]
#endif
            OCI_CANErrorFrameMessage errorFrameMessage;

        /**
        * Specific CAN bus event, e.g.\ bus off.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_BUS_EVENT.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_BUS_EVENT)]
#endif
            OCI_CANEventMessage canEventMessage;

        /**
        * Data of a CAN message.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_INTERNAL_ERROR_EVENT.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_INTERNAL_ERROR_EVENT)]
#endif
            OCI_InternalErrorEventMessage internalErrorEventMessage;

        /**
        * Data of a CAN message.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_TIMER_EVENT.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_TIMER_EVENT)]
#endif
            OCI_TimerEventMessage timerEventMessage;

        /**
        * Data of a CAN message.
        * Use this part, if @ref OCI_CANMessage.type is
        * @ref OCI_CAN_QUEUE_EVENT.
        */
#ifdef MIDL_RUNNING
    [case(OCI_CAN_QUEUE_EVENT)]
#endif
            OCI_QueueEventMessage queueEventMessage;

    } OCI_CANMessageData;


    /**
    * Shared structure of a CAN bus event.
    */

    typedef struct OCI_CANMessage
    {
        /** Discriminator of the @a OCI_CANMessageData union. */
        OCI_CANMessageDataType type;

        /** reserved parameter necessary for 64 Bit alignment of OCI_CANMessageData */
        uint32 reserved;

        /** Data of the message dependent on the @a type of the message. */
#ifdef MIDL_RUNNING
        [switch_is(type)]
#endif
        OCI_CANMessageData data;

    } OCI_CANMessage;


    /**
    * @}
    * @addtogroup GROUP_OCI_CAN_QUEUES Queues
    * @{
    */

    /**
      Queue Data for transmission on a CAN Bus Interface.

      The routine returns, when all frames can be queued. Since the transmit queue has a limited capacity,
      this function may need to block until the last entry could be placed into the queue. A @ref timeout
      can be specified to limit the blocking.

      There is no information, when the frames are send on the CAN bus. There may be a delay between storing the frames
      in the queue and sending them, because of other frames in the same queue and arbitration of the CAN-Bus. Some
      fatal error on the CAN-Bus (e.g. Controller Bus-Off) may occur before the frames can be send.

      When the fatal error condition occurs when the function is executed, this function will return immediately with
      an error code. It will not try to push the remaining messages into the queues. Already queued entries will not
      be discarded.

      @note: A low prior frame in front of a send queue on a busy CAN bus may loose arbitration process with other CAN
      controller and stall the transmission of higher prior frames written to the queue at a later time.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.


      @param[in]  queue     The handle of the @a queue that will transmit the frames.
      @param[in]  timeout   Maximum time (delta, not global time stamp) to wait for messages to be queued.
                            The timeout uses the same resolution as the controller timestamp. The resolution may vary
                            between different driver for different hardware. The interval may be increased to the time
                            slice(s) used by the Operating System and jitter in this magnitude.
                            Use @ref OCI_NO_TIME to wait indefinitely if necessary.
                            0 will queue as many messages as possible without waiting for them to be transmitted.
      @param[in]  messages  A pointer to an array of @a size @ref OCI_CANMessage elements.
      @param[in]  size      The number of entries in the @a messages array.
      @param[out] remaining Number of entries not processed. Will be 0 on success. Will be smaller or equal to @a size,
                            when an error or timeout occured.
                            May be @c NULL.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. All @a messages are queued. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INCONSISTENT_PARAMETER_SET </td>
            <td> At least one message has an invalid format.
                 (e.g.\ messages[i].OCI_CANMessageDataType != OCI_CAN_TX_MESSAGE). </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_QUEUE_IS_FULL </td>
            <td> The specified @a queue is full; at least one message could not be added to the queue. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_UNEXPECTED_NULL </td>
            <td> A fatal internal error occured in queue handling. </td>
       </tr>
       </TABLE>

    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_WriteCANData(
        OCI_QueueHandle queue,
        OCI_Time timeout,
        OCI_CANMessage messages[],
        uint32 size,
        uint32* remaining);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_WriteCANData)(
        OCI_QueueHandle queue,
        OCI_Time timeout,
        OCI_CANMessage messages[],
        uint32 size,
        uint32* remaining);


    /**
      Read entries from a receive queue or wait for a timeout when less than requested entries are available.

      The returned number of entries may be less than the requested number. A non blocking call can be executed,
      when @a timeout is set to 0. Even when waiting an infinite time for the entries the function may return with
      less data.

      This function delivers as long queued data as possible. When the integrity of the returned data can be
      guaranteed the function will not return any error, even when the controller or some part of the driver
      already entered an error state. The function does not block, when the driver is in error state. In this
      case it delivers the remaining data without an error code or - when empty - the error code.

      TODO: describe how OCI_ReadCANData() is not supported for remotely-connected OCDs.

      @controllerState SUSPENDED, RUNNING. \n
                       When the controller is in the CREATED state no valid Queue can exist and the call will return
                       @ref OCI_ERR_INVALID_HANDLE.

      @param[in]  queue     Handle of the receive queue.
      @param[in]  timeout   Maximum time (delta, not global time stamp) to wait at the queue to receive @a size entries.
                            The timeout uses the same resolution as the controller timestamp. The resolution may vary
                            between different driver for different hardware. The interval may be increased to the time
                            slice(s) used by the Operating System and jitter in this magnitude.
                            Use @ref OCI_NO_TIME to wait indefinitely if necessary.
                            0 will fetch the queue's current content.
                            Must not be @c NULL.
      @param[in]  messages  A pointer to an array that can receive @a size @ref OCI_CANMessage elements.
      @param[in]  size      Number of entries allocated in the @a messages array.
                            Must not be 0.
      @param[out] count     Number of entries actually read with 0 <= @a count <= @a size.
                            Must not be @c NULL.
      @param[out] remaining Number of entries still in the queue after moving @a count into @a messages.
                            May be @c NULL.

      @return
      <TABLE border="0" rules="rows" cellspacing="3" cellpadding="3">
       <tr> <td> @ref OCI_SUCCESS </td>
            <td> The operation was successful. @a count entries are filled in the @messages array. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_HANDLE </td>
            <td> The @a queue handle is not valid. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_INVALID_PARAMETER </td>
            <td> The @a messages or @a count parameter is NULL or references an invalid address.</td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_NO_RESPONSE </td>
            <td> The driver for a removable hardware received no response to a request. The hardware may be removed.
                 It is not known wether the request is lost and the command not exectuted or the response is lost and
                 the command was executed. The controller enters the @a DISCONNECTED state. All subsequent calls will
                 return @ref OCI_ERR_DRIVER_DISCONNECTED.
                 Internal resources are locked until OCI_DestroyCANController() for the controller is called. </td>
       </tr>
       <tr> <td> @ref OCI_ERR_DRIVER_DISCONNECTED </td>
            <td> The driver for a removable hardware detected a communication problem (in asynchromous communication,
                 by event signalling or during a previous call to the same hardware) and is not able to communicate to
                 the hardware any more.
                 The state of the controller is @a DISCONNECTED. The command is not executed. All subsequent calls to
                 the same Controller will return @ref OCI_ERR_DRIVER_DISCONNECTED. Internal resources are locked until
                 OCI_DestroyCANController() for the controller is called.  </td>
       </tr>
       <tr> <td> @ref OCI_ERR_OUT_OF_MEMORY </td>
            <td> The driver run out of memory. This error should only occur on heavy loaded systems with multiple
                 clients and large send and receive queues. The error may indicate a resource leak in the driver
                 implementation. When multiple application access the same resource (interface hardware or physical
                 controller) the termination of a different application may return the resources required for this
                 instance. </td>
       </tr>

       </TABLE>

    */

#ifndef OCI_DYNAMICDLL
    OCI_DECLSPEC OCI_ErrorCode
    OCI_CALL OCI_ReadCANData(
        OCI_QueueHandle queue,
        OCI_Time timeout,
        OCI_CANMessage messages[],
        uint32 size,
        uint32* count,
        uint32* remaining);
#endif

    typedef OCI_ErrorCode
    (OCI_CALL* PF_OCI_ReadCANData)(
        OCI_QueueHandle queue,
        OCI_Time timeout,
        OCI_CANMessage messages[],
        uint32 size,
        uint32* count,
        uint32* remaining);


    typedef struct OCI_CANIO_VTable
    {
        PF_OCI_GetCANControllerCapabilities getCANControllerCapabilities;
        PF_OCI_GetCANControllerStatus getCANControllerStatus;

        PF_OCI_CreateCANTxQueue createCANTxQueue;
        PF_OCI_WriteCANData writeCANData;
        PF_OCI_DestroyCANTxQueue destroyCANTxQueue;

        PF_OCI_CreateCANRxQueue createCANRxQueue;
        PF_OCI_ReadCANData readCANData;
        PF_OCI_DestroyCANRxQueue destroyCANRxQueue;

        PF_OCI_AddCANFrameFilter addCANFrameFilter;
        PF_OCI_RemoveCANFrameFilter removeCANFrameFilter;
        PF_OCI_AddCANBusEventFilter addCANBusEventFilter;
        PF_OCI_RemoveCANBusEventFilter removeCANBusEventFilter;
        PF_OCI_AddCANErrorFrameFilter addCANErrorFrameFilter;
        PF_OCI_RemoveCANErrorFrameFilter removeCANErrorFrameFilter;
    } OCI_CANIO_VTable;

    /** @} */

    /** @} */

#ifdef __cplusplus
}
#endif

#endif
